<?php
/**
 * Created by PhpStorm.
 * User: Administrator
 * Date: 2015/12/25
 * Time: 11:38
 */

namespace framework\db;

use framework\components\ToolsAbstract;

class Connection extends \yii\db\Connection
{
    public $commandClass = 'framework\db\Command';
    protected $_checkInterval = 5;
    protected $_lastCheckTime = 0;
    protected $_slaveLastCheckTime = 0;
    public $serverRetryInterval = 120;
    /**
     * @var \yii\db\Connection
     */
    protected $slaveDb = null;

    /**
     * 另外考虑到连接效率的问题，
     * 可以设置尝试重连的时间为mysql服务器的interactive_timeout,wait_timeout时间，
     * 当时间大于该值时才去检查数据库连接。
     * @throws \yii\base\InvalidConfigException
     * @throws \yii\db\Exception
     */
    public function check()
    {
        $this->log(__METHOD__);
        $elapse = time() - $this->_lastCheckTime;
        //的时间小于最小检查间隔时间则不进行检查
        if ($elapse < $this->_checkInterval) {
            $this->log('no need to check master connection');
            return true;
        }

        try {
            if (!$this->pdo) {
                $this->open();
                $this->log('PDO init master connection');
            }
            $info = $this->pdo->getAttribute(\PDO::ATTR_SERVER_INFO);
            if (preg_match('/[a-zA-Z]+:\s+\d+\.?\d+/', $info, $matches)) {
                $this->log($info);
                $this->log('PDO master connected');
                $this->_lastCheckTime = time();
            } else {
                $this->reconnect();
            }
        } catch (\PDOException $e) {
            $this->log('PDOException master reconnect');
            $this->reconnect();
        } catch (\Exception $e) {
            $this->log('Exception master  reconnect');
            $this->reconnect();
        }
    }

    /**
     * 另外考虑到连接效率的问题，
     * 可以设置尝试重连的时间为mysql服务器的interactive_timeout,wait_timeout时间，
     * 当时间大于该值时才去检查数据库连接。
     * @throws \yii\base\InvalidConfigException
     * @throws \yii\db\Exception
     */
    public function checkSlave()
    {
        $this->log(__METHOD__);
        $elapse = time() - $this->_slaveLastCheckTime;
        //的时间小于最小检查间隔时间则不进行检查
        if ($elapse < $this->_checkInterval) {
            $this->log('no need to check slave connection');
            return true;
        }

        try {
            $info = $this->slaveDb->pdo->getAttribute(\PDO::ATTR_SERVER_INFO);
            if (preg_match('/[a-zA-Z]+:\s+\d+\.?\d+/', $info, $matches)) {
                $this->log($info);
                $this->log('PDO slave connected');
                $this->_slaveLastCheckTime = time();
            } else {
                $this->slaveDb = null;
            }
        } catch (\PDOException $e) {
            $this->log('PDOException slave reconnect');
            $this->slaveDb = null;
        } catch (\Exception $e) {
            $this->log('Exception  slave reconnect');
            $this->slaveDb = null;
        }
    }

    protected function reconnect()
    {
        $this->close();
        $this->open();
        $this->_lastCheckTime = time();
        $info = $this->pdo->getAttribute(\PDO::ATTR_SERVER_INFO);
        if (preg_match('/[a-zA-Z]+:\s+\d+\.?\d+/', $info, $matches)) {
            $this->log('PDO master reconnect after_:' . $info);
        } else {
            $this->log('PDO master reconnect failed:' . $info);
        }
    }

    protected function log($msg)
    {
//        ToolsAbstract::log($msg, "connection.log");
    }

    /**
     * Returns the currently active slave connection.
     * If this method is called for the first time, it will try to open a slave connection when [[enableSlaves]] is true.
     * @param bool $fallbackToMaster whether to return a master connection in case there is no slave connection available.
     * @return \yii\db\Connection the currently active slave connection. `null` is returned if there is no slave available and
     * `$fallbackToMaster` is false.
     */
    public function getSlave($fallbackToMaster = true)
    {
        if (!$this->enableSlaves) {
            return $fallbackToMaster ? $this : null;
        }

        if ($this->slaveDb === null) {
            $this->slaveDb = $this->openFromPool($this->slaves, $this->slaveConfig);
        }
        if ($this->slaveDb) {
            $this->checkSlave();
        }
        if ($this->slaveDb === null) {
            $this->log('fallbackToMaster');
        } else {
            $this->log('UseSlaveDB');
        }
        return $this->slaveDb === null && $fallbackToMaster ? $this : $this->slaveDb;
    }

    public function beginTransaction($isolationLevel = null)
    {
        $this->check();
        return parent::beginTransaction($isolationLevel); // TODO: Change the autogenerated stub
    }
}